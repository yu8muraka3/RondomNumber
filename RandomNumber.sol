pragma solidity ^0.4.8;
contract RandomNumber {
    address owner;

    // maximum number of random numbers
    uint numberMax;

    // draw object
    struct draw {
        // seed number for generating a random number
        uint blockNumber;
    }

    struct draws {
        // index
        uint numDraws;
        mapping (uint => draw) draws;
    }

    // manage by user
    mapping (address => draws) requests;

    event ReturnNextIndex(uint _index);

    // generate a random number
    function RandomNumber(uint _max) {
        owner = msg.sender;
        numberMax = _max;
    }

    function request() returns (uint) {
        // requesting user(address)'s index
        uint _nextIndex = requests[msg.sender].numDraws;
        requests[msg.sender].draws[_nextIndex].blockNumber = block.number;

        // next index number
        requests[msg.sender].numDraws = _nextIndex + 1;
        ReturnNextIndex(_nextIndex);
        return _nextIndex;
    }

    function get(uint _index) constant returns (int status, bytes32 blockhash,
    bytes32 seed, uint drawnNumber) {
        // there is not index in draw objects
        if (_index >= requests[msg.sender].numDraws) {
            return (-2, 0, 0, 0);
        }
        else {
            // next blockNumber
            uint _nextBlockNumber = requests[msg.sender].draws[_index].blockNumber + 1;

            // new block has been not yet mining
            if (_nextBlockNumber >= block.number) {
                return (-1, 0, 0, 0);
            }
            else {
                bytes32 _blockhash = block.blockhash(_nextBlockNumber);

                // seed is generated by these parameters
                bytes32 _seed = sha256(_blockhash, msg.sender, _index);

                // generate random number by seed
                uint _drawnNumber = uint(_seed) % numberMax + 1;

                return (0, _blockhash, _seed, _drawnNumber);
            }
        }
    }
}
